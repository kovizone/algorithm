# Algorithm

## 1. 倒水问题

若干个水桶，各个水桶为不同的容量（单位：L），其中若干个水桶是满的,需要通过各个水桶互相倒水，倒出所需的水量，每次只能倒空或倒满，不能洒出；

如：有8L、5L、3L三个水桶，8L水桶是满的，需要倒出4L的水在某个容器中的步骤；

## 2. 整型相加（领扣1）

要求不使用加运算符；

## 3. 最后的零（领扣2）

计算出n阶乘中尾部零的个数；

如：11! = 399168, 结尾的0有2个；

## 4. 统计数字（领扣3）

计算数字 k 在 0 到 n 中的出现的次数，k 可能是 0~9 的一个值；

在 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12] 中，我们发现 1 出现了 5 次 (1, 10, 11, 12)(注意11中有两个1)；

## 5. 丑数 II（领扣4）

设计一个算法，找出只含素因子2，3，5 的第 n 小的数。

符合条件的数如：1, 2, 3, 4, 5, 6, 8, 9, 10, 12...

我们可以认为 1 也是一个丑数。

## 6. 超级丑数（领扣518）

写一个程序来找第 n 个超级丑数。

超级丑数是所有的质数因子都在给定的的质数集合内的正整数。

比如给定质数集合 [2, 7, 13, 19], 那么 [1, 2, 4, 7, 8, 13, 14, 16, 19, 26, 28, 32] 是前 12 个超级丑数。

## 7. 第K大元素（领扣5）

在数组中找到第 k 大的元素。

> 待优化

## 8. 骰子求和（领扣20）

扔 n 个骰子，向上面的数字之和为 S。给定 n，请列出所有可能的 S 值及其相应的概率。

> 未解决

## 9. 两数相加（力扣2）

给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。

如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。

您可以假设除了数字 0 之外，这两个数都不会以 0 开头。

## 10. 字符串相乘（力扣43）

给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。

## 11. 字符串相加（力扣415）

给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。

## 12. 接雨水（力扣42）

给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

## 13. 接雨水2（力扣407）

给定一个 m x n 的矩阵，其中的值均为正整数，代表二维高度图每个单元的高度，请计算图中形状最多能接多少体积的雨水。

> 未解决

## 14. 数字1的个数（力扣233）

给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。

## 15. 基本计算器（力扣224）

实现一个基本的计算器来计算一个简单的字符串表达式的值。

字符串表达式可以包含左括号 ( ，右括号 )，加号 + ，减号 -，非负整数和空格  。

## 16. 基本计算器 II（力扣227）

实现一个基本的计算器来计算一个简单的字符串表达式的值。

字符串表达式仅包含非负整数，+， - ，*，/ 四种运算符和空格  。 整数除法仅保留整数部分。

## 17. 缺失的第一个正数（力扣41）

给定一个未排序的整数数组，找出其中没有出现的最小的正整数。

你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间。

> 官方解

## 18. 解数独（力扣37）

编写一个程序，通过已填充的空格来解决数独问题。

一个数独的解法需遵循如下规则：

1. 数字 1-9 在每一行只能出现一次。
2. 数字 1-9 在每一列只能出现一次。
3. 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。

空白格用 '.' 表示。

## 19. 分发糖果（力扣135）

老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。

你需要按照以下要求，帮助老师给这些孩子分发糖果：

1. 每个孩子至少分配到 1 个糖果。
2. 相邻的孩子中，评分高的孩子必须获得更多的糖果。

那么这样下来，老师至少需要准备多少颗糖果呢？

> 内存溢出

## 20. 全 O(1) 的数据结构（力扣432）

实现一个数据结构支持以下操作：

1. Inc(key) - 插入一个新的值为 1 的 key。或者使一个存在的 key 增加一，保证 key 不为空字符串。
2. Dec(key) - 如果这个 key 的值是 1，那么把他从数据结构中移除掉。否者使一个存在的 key 值减一。如果这个 key 不存在，这个函数不做任何事情。key 保证不为空字符串。
3. GetMaxKey() - 返回 key 中值最大的任意一个。如果没有元素存在，返回一个空字符串""。
4. GetMinKey() - 返回 key 中值最小的任意一个。如果没有元素存在，返回一个空字符串""。

挑战：以 O(1) 的时间复杂度实现所有操作。

> 未解决

## 21. 青蛙过河（力扣403）

一只青蛙想要过河。 假定河流被等分为 x 个单元格，并且在每一个单元格内都有可能放有一石子（也有可能没有）。 青蛙可以跳上石头，但是不可以跳入水中。

给定石子的位置列表（用单元格序号升序表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一个石子上）。 开始时， 青蛙默认已站在第一个石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格1跳至单元格2）。

如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。

请注意：

1. 石子的数量 ≥ 2 且 < 1100；
2. 每一个石子的位置序号都是一个非负整数，且其 < 231；
3. 第一个石子的位置永远是0。